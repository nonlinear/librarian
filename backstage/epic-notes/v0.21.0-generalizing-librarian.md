# v0.21.0 - Generalizing Librarian (Skill Portability)

**Created:** 2026-02-21  
**Status:** ðŸ“‹ PROPOSED

**Make librarian skill portable and self-contained**

---

## Problem

**Current state:**
- Skill assumes hardcoded paths (`~/Documents/librarian/skill/`)
- No onboarding process (user must know where to put files)
- Indexing separate from skill (manual `index_library.py`)
- Every user's setup is bespoke (no standardization)

**Pain points:**
- Hard to share skill with others
- Hard to move to different machine
- Hard to manage multiple instances (work vs personal library)
- Configuration scattered (no single source of truth)

---

## Solution

**Make skill self-aware and interactive:**

1. **Onboarding:** `setup librarian` - guided configuration
2. **Embedded indexing:** `update librarian` - skill manages own indexes
3. **Per-instance variables:** Support multiple libraries with different configs

---

## Tasks

### 1. Onboarding Skill ("setup librarian")

**Goal:** Interactive setup asking where things are, how they should be configured

**Flow:**
```
User: "setup librarian"
Skill: "Where are your books?"
User: "~/Documents/books"
Skill: "Where should I store indexes?"
User: "~/Documents/librarian/indexes"
Skill: "Which embedding model? (bge-small-en-v1.5, all-MiniLM-L6-v2)"
User: "bge-small-en-v1.5"
Skill: "âœ… Config saved. Run 'update librarian' to index."
```

**Implementation:**
- [ ] Create `setup.sh` script (interactive prompts)
- [ ] Generate `.librarian-config.json` (per-instance config)
- [ ] Store config location (global vs per-skill-instance)
- [ ] Validate paths (books exist, writable indexes folder)
- [ ] Handle edge cases (config exists, overwrite?)

**Config format:**
```json
{
  "schema_version": "1.0",
  "books_path": "~/Documents/books",
  "indexes_path": "~/Documents/librarian/indexes",
  "embedding_model": "bge-small-en-v1.5",
  "chunk_size": 1024,
  "chunk_overlap": 200
}
```

---

### 2. Embed Indexing on Skill ("update librarian")

**Goal:** Skill manages indexing without external commands

**Flow:**
```
User: "update librarian"
Skill: 
  - Reads config
  - Scans books_path for new/changed files
  - Runs indexing (smart mode)
  - Updates metadata
  - Reports: "âœ… Indexed 5 new books, updated 2 topics"
```

**Implementation:**
- [ ] Wrap `index_library.py` logic in skill
- [ ] Add smart detection (only index changed files)
- [ ] Progress feedback (user sees what's happening)
- [ ] Handle errors gracefully (book corrupt, model missing)
- [ ] Update `.library-index.json` after indexing

**Commands:**
- `update librarian` - smart update (new/changed only)
- `update librarian --full` - reindex everything
- `update librarian --topic magick_chaos` - reindex specific topic

---

### 3. Per-Skill Instance Variables

**Goal:** Support multiple librarian instances (work, personal, research)

**Use case:**
- Work library: `~/Work/library` (tech books, project docs)
- Personal library: `~/Documents/books` (fiction, magick, theory)
- Research library: `~/Research/papers` (academic papers)

**Proposal A: Environment variables**
```bash
LIBRARIAN_CONFIG=~/Work/.librarian-config.json
```

**Proposal B: Named instances**
```bash
# Setup instances
setup librarian --instance work --books ~/Work/library
setup librarian --instance personal --books ~/Documents/books

# Use instance
research for X --instance work
```

**Proposal C: Config paths**
```bash
# Skill looks for config in order:
1. ./.librarian-config.json (current dir)
2. ~/.librarian-config.json (home dir)
3. ~/Documents/librarian/.librarian-config.json (default)
```

**Tasks:**
- [ ] **DECIDE:** Which approach? (env vars vs named instances vs path-based)
- [ ] Implement instance selection logic
- [ ] Update wrapper to pass config path
- [ ] Test multiple instances (no conflicts)
- [ ] Document multi-instance workflow

**Open question:** How does user specify which instance during query?

---

## Success Criteria

**Onboarding:**
- âœ… New user runs `setup librarian`, answers questions, gets working config
- âœ… Config validation catches errors (missing paths, invalid models)
- âœ… Can reconfigure without breaking existing indexes

**Embedded indexing:**
- âœ… `update librarian` indexes new books automatically
- âœ… Smart detection (only changed files)
- âœ… User sees progress (not black box)
- âœ… Errors handled gracefully (corrupt book = skip, report)

**Per-instance variables:**
- âœ… Can run multiple libraries on same machine
- âœ… No conflicts between instances
- âœ… Clear which instance is active
- âœ… Easy to switch instances

---

## Dependencies

**Blocks:**
- None (can implement alongside other epics)

**Blocked by:**
- v0.15.0 complete (skill protocol stable)
- v0.16.0 preferred (unified indexing helps)

---

## Design Questions

**1. Where to store config?**
- Global (`~/.librarian-config.json`) vs per-instance?
- How to discover config location?

**2. How to handle multiple instances?**
- Env vars, named instances, or path-based?
- User UX: explicit instance selection vs auto-detection?

**3. Skill vs wrapper responsibility?**
- Should skill run indexing directly or call wrapper?
- Error handling: skill layer or wrapper layer?

**4. Backward compatibility?**
- Current hardcoded paths = breaking change?
- Migration path for existing users?

---

## Future Enhancements (v0.22.0+)

**Auto-update triggers:**
- Watch folder for new books â†’ auto-index
- Cron job â†’ daily smart update
- Pre-query check â†’ index stale? update first

**Cloud sync:**
- Config synced across machines (iCloud, Dropbox)
- Indexes portable (or regenerate on new machine)

**Shared configs:**
- Team library (same config, different users)
- Read-only vs read-write access

---

**Next steps:**
1. Design config schema (onboarding questions â†’ JSON)
2. Prototype `setup.sh` (interactive flow)
3. Decide instance selection approach
4. Implement embedded indexing wrapper
5. Test multi-instance workflow
